// 1. JS version is used when there is need for more items then $max-items. CSS variable is generated by JS.
// 2. In JS version, there is toggle of opacity because of transition effect on initialization (active item is not always the last one)
// 3. Label has z-index 2, so it's always on top of the highlight, last one contains pseudo element with highlight, so checked label has z-index 3.
// 4. Because of truncate on the text inside of label we need to set min-width, otherwise flex will overflow and all items will not have the same width.
// 5. Due to the selector's specificity, it cannot be made less specific.
// 6. Opacity is initially set to 0 to prevent visual shifting during initialization. JS sets the CSS variable value and applies the `is-transitioning` class on change to enable transitions.

@use '@tokens' as tokens;
@use '../../tools/accessibility';
@use '../../tools/dictionaries';
@use '../../tools/typography';
@use 'theme';
@use 'tools';

.SegmentedControlItem__label {
    @include typography.generate(theme.$item-label-typography);

    position: relative;
    z-index: 2;
    display: flex;
    flex: 1 0 0;
    column-gap: theme.$item-gap;
    align-items: center;
    justify-content: center;
    min-width: theme.$item-min-width; // 4.
    height: theme.$item-height;
    padding-inline: theme.$item-padding-y;
    padding-block: theme.$item-padding-x;
    border-radius: theme.$item-border-radius;
    user-select: none;
    cursor: pointer;
    transition: inherit;

    @media (hover: hover) {
        :not(:checked, :disabled) + &:hover {
            background-color: theme.$item-background-hover;
            transition: theme.$transition-hover;
        }
    }

    &::after {
        content: '';
        position: absolute;
        inset: 0;
        z-index: -1;
        border: theme.$item-border-default;
        border-radius: theme.$item-border-radius;
        transform: translateX(
            calc(
                var(--#{tokens.$css-variable-prefix}segmented-control-highlight-pos, 0) *
                    -100% - calc(
                        var(--#{tokens.$css-variable-prefix}segmented-control-highlight-pos, 0) * #{theme.$gap}
                    )
            )
        );
        pointer-events: none;
        transition: inherit;
    }
}

.SegmentedControlItem__label > svg {
    flex-shrink: 0;
}

.SegmentedControlItem__input {
    @include accessibility.hide-text();

    &:focus-visible + .SegmentedControlItem__label {
        box-shadow: theme.$focus-ring;
    }

    &:disabled + .SegmentedControlItem__label {
        color: theme.$item-disabled-color;
        cursor: theme.$item-disabled-cursor;
    }

    &:checked + .SegmentedControlItem__label {
        z-index: 3; // 3.
        color: var(--#{tokens.$css-variable-prefix}segmented-control-item-color);
    }
}

@include dictionaries.generate-variants(
    $class-name: 'SegmentedControl',
    $dictionary-values: theme.$fill-variant-dictionary,
    $config: theme.$fill-variant-active-config,
    $infix: 'item'
);

// stylelint-disable selector-max-specificity -- 5.
.SegmentedControl > [type='radio']:last-of-type + .SegmentedControlItem__label::after,
.SegmentedControl [type='checkbox']:checked + .SegmentedControlItem__label::after,
.SegmentedControl :last-of-type:has([type='radio']) > .SegmentedControlItem__label::after {
    border-color: var(--#{tokens.$css-variable-prefix}segmented-control-item-border-color);
    background-color: var(--#{tokens.$css-variable-prefix}segmented-control-item-background-color);
    box-shadow: var(--#{tokens.$css-variable-prefix}segmented-control-item-box-shadow);
}
// stylelint-enable selector-max-specificity

@include tools.generate-item-transform(theme.$max-items);

// 1.
.SegmentedControl[data-spirit-toggle]:has([type='radio']) {
    // stylelint-disable-next-line  selector-max-specificity -- 5.
    &:not(.is-initialized) ::after {
        opacity: 0; // 6.
    }

    // stylelint-disable-next-line  selector-max-specificity -- 5.
    &:not(.is-transitioning) ::after {
        transition: none; // 6.
    }
}
