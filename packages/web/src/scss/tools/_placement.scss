// 1. `--placement-offset` is a custom property to translate along the main placement axis.
// 2. `--placement-offset-orthogonal` is a custom property to translate orthogonal to the main placement axis.
//    It can be reset to 0 in case of an absolutely positioned child element that only needs the
//    `$offset` property, typically when the placement is controlled e.g. by Floating UI.

@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
@use 'list' as spirit-list;

$_inset-map: (
    top: auto auto 100% 50%,
    top-left: auto auto 100% 0,
    top-right: auto 0 100% auto,
    bottom: 100% auto auto 50%,
    bottom-left: 100% auto auto 0,
    bottom-right: 100% 0 auto auto,
    left: 50% 100% auto auto,
    left-top: 0 100% auto auto,
    left-bottom: auto 100% 0 auto,
    right: 50% auto auto 100%,
    right-top: 0 auto auto 100%,
    right-bottom: auto auto 0 100%,
);

// 1., 2.
$_child-translate-map: (
    top: var(--placement-offset-orthogonal, -50%) calc(-1 * var(--placement-offset, 0)),
    top-left: var(--placement-offset-orthogonal, 0) calc(-1 * var(--placement-offset, 0)),
    top-right: var(--placement-offset-orthogonal, 0) calc(-1 * var(--placement-offset, 0)),
    bottom: var(--placement-offset-orthogonal, -50%) var(--placement-offset, 0),
    bottom-left: var(--placement-offset-orthogonal, 0) var(--placement-offset, 0),
    bottom-right: var(--placement-offset-orthogonal, 0) var(--placement-offset, 0),
    left: calc(-1 * var(--placement-offset, 0)) var(--placement-offset-orthogonal, -50%),
    left-top: calc(-1 * var(--placement-offset, 0)) var(--placement-offset-orthogonal, 0),
    left-bottom: calc(-1 * var(--placement-offset, 0)) var(--placement-offset-orthogonal, 0),
    right: var(--placement-offset, 0) var(--placement-offset-orthogonal, -50%),
    right-top: var(--placement-offset, 0) var(--placement-offset-orthogonal, 0),
    right-bottom: var(--placement-offset, 0) var(--placement-offset-orthogonal, 0),
);
$_arrow-translate-map: (
    top: -50% 0%,
    top-left: var(--placement-arrow-corner-offset) 0%,
    top-right: calc(-1 * var(--placement-arrow-corner-offset)) 0%,
    bottom: -50% -100%,
    bottom-left: var(--placement-arrow-corner-offset) -100%,
    bottom-right: calc(-1 * var(--placement-arrow-corner-offset)) -100%,
    left: 50% -100%,
    left-top: calc(var(--placement-arrow-width) / 2)
        calc(var(--placement-arrow-width) / 2 - var(--placement-arrow-height) + var(--placement-arrow-corner-offset)),
    left-bottom: calc(var(--placement-arrow-width) / 2)
        calc(var(--placement-arrow-width) / -2 - var(--placement-arrow-corner-offset)),
    right: -50% -100%,
    right-top: calc(var(--placement-arrow-width) / -2)
        calc(var(--placement-arrow-width) / 2 - var(--placement-arrow-height) + var(--placement-arrow-corner-offset)),
    right-bottom: calc(var(--placement-arrow-width) / -2)
        calc(var(--placement-arrow-width) / -2 - var(--placement-arrow-corner-offset)),
);
$_arrow-rotate-map: (
    top: 0deg,
    top-left: 0deg,
    top-right: 0deg,
    bottom: 180deg,
    bottom-left: 180deg,
    bottom-right: 180deg,
    left: -90deg,
    left-top: -90deg,
    left-bottom: -90deg,
    right: 90deg,
    right-top: 90deg,
    right-bottom: 90deg,
);
$_placement-inverse-map: (
    top: bottom,
    bottom: top,
    left: right,
    right: left,
);

// Function to return an inverse placement name
// Example: inverse('top') will return 'bottom'
// Example: inverse('top-left') will return 'bottom-right'
// Example: inverse('top-left', true) will return 'bottom-left'
// Example: inverse('top-left', true, false) will return 'bottom left'
@function inverse($placement, $main-axis-only: false, $hyphenate: true) {
    $hyphen: '-';
    $placement-chunks: string.split($placement, $hyphen);
    $placement-inverse-chunks: ();
    $join-with: if($hyphenate, $hyphen, ' ');

    @for $i from 1 through list.length($placement-chunks) {
        $chunk: list.nth($placement-chunks, $i);
        $new-chunk: null;

        @if $main-axis-only and $i > 1 {
            $new-chunk: $chunk;
        } @else {
            $new-chunk: map.get($_placement-inverse-map, $chunk);
        }

        $placement-inverse-chunks: list.append($placement-inverse-chunks, $new-chunk);
    }

    @return spirit-list.to-string($placement-inverse-chunks, $join-with);
}

// Base styles for parent element
@mixin parent() {
    position: relative;
}

// Base styles for child element
@mixin child($z-index: 1) {
    position: absolute;
    z-index: $z-index;
}

// Base styles for the arrow element
@mixin arrow($width, $height, $corner-offset) {
    --placement-arrow-width: #{$width};
    --placement-arrow-height: #{$height};
    --placement-arrow-corner-offset: #{$corner-offset};

    position: absolute;
    transform-origin: bottom center;
}

// Mixin to generate child placement styles by a placement name
// Parameters are:
// * $placement: the placement name
// * $offset: the offset of child from its parent, typically to make place for arrow
@mixin child-variant($placement, $offset: 0) {
    --placement-offset: #{$offset}; // 1.

    inset: map.get($_inset-map, $placement);
    translate: map.get($_child-translate-map, $placement);
    transform-origin: string.unquote(inverse($placement, $hyphenate: false));
}

// Mixin to generate child arrow styles by a placement name
// Parameters are:
// * $placement: the placement name
@mixin arrow-variant($placement) {
    inset: map.get($_inset-map, $placement);
    translate: map.get($_arrow-translate-map, $placement);
    rotate: z map.get($_arrow-rotate-map, $placement);
}
