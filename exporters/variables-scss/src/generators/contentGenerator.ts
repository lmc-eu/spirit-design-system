import { Token, TokenGroup, TokenType } from '@supernovaio/sdk-exporters';
import { generateStylesFromTokens } from './stylesGenerator';
import { StylesObjectType, generateStylesObjectFromTokens } from './stylesObjectGenerator';
import { formatCSS } from '../formatters/cssFormatter';
import { convertToJs, convertToScss, deepMergeObjects } from '../helpers/objectHelper';
import { FileData } from '../config/fileConfig';

// Add disclaimer to the top of the content
export const addDisclaimer = (content: string): string => {
  return `/* This file was generated by Supernova, don't change manually */\n${content}`;
};

export const filterTokensByTypeAndGroup = (tokens: Token[], type: TokenType, group: string) => {
  return tokens.filter((token) => {
    const hasMatchingType = token.tokenType === type;
    const isInGroup = token.origin?.name?.includes(group);
    const hasValidTypography = !(token.tokenType === TokenType.typography && token.name.includes('-Underline'));

    return hasMatchingType && isInGroup && hasValidTypography;
  });
};

export const generateJsObjectOutput = (stylesObject: StylesObjectType): string => {
  return Object.entries(stylesObject)
    .map(([key, obj]) => `export const ${key} = {\n${convertToJs(obj as StylesObjectType)}\n};\n\n`)
    .join('');
};

export const generateScssObjectOutput = (stylesObject: StylesObjectType): string => {
  return Object.entries(stylesObject)
    .map(([key, obj]) => `${key}: (\n${convertToScss(obj as StylesObjectType)}\n) !default;\n\n`)
    .join('');
};

export const generateFileContent = (
  tokens: Token[],
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
  fileData: FileData,
  hasJsOutput: boolean,
) => {
  let styledTokens = '';
  let stylesObject: StylesObjectType = {};
  const { groupNames, hasParentPrefix = true, sortByNumValue = false, withStylesObject = true, tokenTypes } = fileData;

  // Iterate over token types and group names to filter tokens
  tokenTypes.forEach((tokenType) => {
    groupNames.forEach((group) => {
      const filteredTokens = filterTokensByTypeAndGroup(tokens, tokenType, group);

      // Generate css tokens
      if (tokenType !== TokenType.typography) {
        styledTokens += generateStylesFromTokens(
          filteredTokens,
          mappedTokens,
          tokenGroups,
          group,
          hasParentPrefix,
          sortByNumValue,
          hasJsOutput,
        );
        styledTokens += '\n\n';
      }

      // Generate css object and merge it with the existing one
      const groupStylesObject = generateStylesObjectFromTokens(
        filteredTokens,
        mappedTokens,
        tokenGroups,
        hasParentPrefix,
        hasJsOutput,
      );
      stylesObject = deepMergeObjects(stylesObject, groupStylesObject);
    });
  });

  let content = styledTokens;

  // convert css object to scss or js structure based on file extension
  if (withStylesObject) {
    content += hasJsOutput ? generateJsObjectOutput(stylesObject) : generateScssObjectOutput(stylesObject);
  }

  return {
    content: addDisclaimer(formatCSS(content)),
  };
};
