import { Token, TokenGroup, TokenType } from '@supernovaio/sdk-exporters';
import { generateStylesFromTokens } from './stylesGenerator';
import { StylesObjectType, generateStylesObjectFromTokens } from './stylesObjectGenerator';
import { formatStyles } from '../formatters/stylesFormatter';
import { convertToJs, convertToScss, deepMergeObjects } from '../helpers/objectHelper';
import { FileData } from '../config/fileConfig';

// Add disclaimer to the top of the content
export const addDisclaimer = (content: string): string => {
  return `/* This file was generated by Supernova, don't change manually */\n${content}`;
};

export const filterTokensByTypeAndGroup = (tokens: Token[], type: TokenType, group: string) => {
  return tokens.filter((token) => {
    const hasMatchingType = token.tokenType === type;
    const isInGroup = token.origin?.name?.includes(group);
    const hasValidTypography = !(token.tokenType === TokenType.typography && token.name.includes('-Underline'));

    return hasMatchingType && isInGroup && hasValidTypography;
  });
};

export const generateJsObjectOutput = (stylesObject: StylesObjectType): string => {
  return Object.entries(stylesObject)
    .map(([key, obj]) => `export const ${key} = {\n${convertToJs(obj as StylesObjectType)}\n};\n\n`)
    .join('');
};

export const generateScssObjectOutput = (stylesObject: StylesObjectType): string => {
  return Object.entries(stylesObject)
    .map(([key, obj]) => `${key}: (\n${convertToScss(obj as StylesObjectType)}\n) !default;\n\n`)
    .join('');
};

export const getGroups = (tokens: Token[], excludeGroupNames: string[] | null, groupNames: string[]): string[] => {
  let groups;

  if (excludeGroupNames && excludeGroupNames.length > 0) {
    const filteredTokens = tokens.filter((token) => {
      return !excludeGroupNames.some((excludedGroup) => token.origin?.name?.includes(excludedGroup));
    });

    const restOfGroupNames = filteredTokens.reduce((acc: string[], token) => {
      const groupName = token.origin?.name?.split('/')[0];
      if (groupName && !acc.includes(groupName)) {
        acc.push(groupName);
      }

      return acc;
    }, []);

    groups = [...new Set(restOfGroupNames)];
  } else {
    groups = groupNames;
  }

  return groups;
};

export const generateFileContent = (
  tokens: Token[],
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
  fileData: FileData,
  hasJsOutput: boolean,
) => {
  let styledTokens = '';
  let stylesObject: StylesObjectType = {};
  const {
    groupNames = [''],
    hasParentPrefix = true,
    sortByNumValue = false,
    hasStylesObject = true,
    tokenTypes,
    excludeGroupNames = null,
  } = fileData;

  // Iterate over token types and groups to filter tokens
  tokenTypes.forEach((tokenType) => {
    const groups = getGroups(tokens, excludeGroupNames, groupNames);

    groups.forEach((group) => {
      const filteredTokens = filterTokensByTypeAndGroup(tokens, tokenType, group);

      // Generate css tokens
      if (tokenType !== TokenType.typography) {
        styledTokens += generateStylesFromTokens(
          filteredTokens,
          mappedTokens,
          tokenGroups,
          group,
          hasParentPrefix,
          sortByNumValue,
          hasJsOutput,
        );
        styledTokens += '\n\n';
      }

      // Generate css object and merge it with the existing one
      const groupStylesObject = generateStylesObjectFromTokens(
        filteredTokens,
        mappedTokens,
        tokenGroups,
        hasParentPrefix,
        hasJsOutput,
      );
      stylesObject = deepMergeObjects(stylesObject, groupStylesObject);
    });
  });

  let content = styledTokens;

  // convert css object to scss or js structure based on file extension
  if (hasStylesObject) {
    content += hasJsOutput ? generateJsObjectOutput(stylesObject) : generateScssObjectOutput(stylesObject);
  }

  return {
    content: addDisclaimer(formatStyles(content, hasJsOutput)),
  };
};
