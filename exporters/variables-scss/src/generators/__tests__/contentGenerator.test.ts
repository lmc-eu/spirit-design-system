import fs from 'fs';
import path from 'path';
import { Token, TokenGroup, TokenType } from '@supernovaio/sdk-exporters';
import { generateFileContent, addDisclaimer, filterTokensByTypeAndGroup } from '../contentGenerator';
import {
  exampleMockedGroups,
  exampleMockedTokens,
  exampleTypographyMockedTokens,
} from '../../../tests/fixtures/mockedExampleTokens';
import { FileData } from '../../config/fileConfig';

const mockedExpectedResult = fs.readFileSync(
  path.join(__dirname, '../../../tests/fixtures/exampleFileContent.scss'),
  'utf-8',
);
const mappedTokens: Map<string, Token> = new Map([]);
const tokenGroups: Array<TokenGroup> = exampleMockedGroups;

describe('contentGenerator', () => {
  describe('generateFileContent', () => {
    it('should generate file content', () => {
      const tokens = Array.from(exampleMockedTokens.values());
      const fileData: FileData = {
        fileName: 'testFile',
        tokenTypes: [TokenType.dimension, TokenType.string],
        groupNames: ['Grid', 'String'],
        withCssObject: true,
        hasParentPrefix: true,
        sortByNumValue: false,
      };

      const fileContent = generateFileContent(tokens, mappedTokens, tokenGroups, fileData, false);

      expect(fileContent).toStrictEqual({ content: mockedExpectedResult });
    });
  });

  describe('addDisclaimer', () => {
    it('should add disclaimer to the top of the content', () => {
      const content = '/* This is a test content */';
      const expectedContent = `/* This file was generated by Supernova, don't change manually */\n${content}`;

      expect(addDisclaimer(content)).toBe(expectedContent);
    });
  });

  describe('filterTokensByTypeAndGroup', () => {
    const dataProviderItems = [
      {
        type: TokenType.dimension,
        group: 'Grid',
        tokenIdentifier: 'dimensionRef',
        description: 'dimension token type and Grid group',
      },
      {
        type: TokenType.string,
        group: 'Grid',
        tokenIdentifier: 'stringRef',
        description: 'string token type and Grid group',
      },
    ];

    const dataTypographyProviderItems = {
      type: TokenType.typography,
      group: 'Heading',
      tokenIdentifier: 'typographyHeadingRef1',
    };

    it.each(dataProviderItems)('should filter $description', ({ type, group, tokenIdentifier }) => {
      const tokens = Array.from(exampleMockedTokens.values());
      const expectedTokens = [exampleMockedTokens.get(tokenIdentifier) as Token];

      expect(filterTokensByTypeAndGroup(tokens, type, group)).toStrictEqual(expectedTokens);
    });

    it(`should filter ${dataTypographyProviderItems.type} token type and ${dataTypographyProviderItems.group} group and exclude tokens with "-Underline"`, () => {
      const tokens = Array.from(exampleTypographyMockedTokens.values());
      const expectedTokens = [exampleTypographyMockedTokens.get(dataTypographyProviderItems.tokenIdentifier) as Token];

      const filteredTokens = filterTokensByTypeAndGroup(
        tokens,
        dataTypographyProviderItems.type,
        dataTypographyProviderItems.group,
      );

      expect(filteredTokens).toStrictEqual(expectedTokens);
    });
  });
});
