import { Token, TokenGroup, TokenType } from '@supernovaio/sdk-exporters';
import { FileData } from '../config/fileConfig';
import { indentAndFormat } from '../formatters/stylesFormatter';
import { convertToJs, convertToScss, deepMergeObjects } from '../helpers/objectHelper';
import { generateStylesFromTokens } from './stylesGenerator';
import { DeviceDimensionMap, type StylesObjectType, generateStylesObjectFromTokens } from './stylesObjectGenerator';
import { findTokenPrefix } from '../helpers/findTokenPrefix';
import { filterExcludedTokens } from '../filters/excludedTokens';
import { generateMixinFromTokens } from './mixinGenerator';
import { getFontSizeBaseMap, type FontSizeBaseMap } from '../helpers/unitHelper';
import { getTokenGroup } from '../helpers/tokenHelper';

// Add disclaimer to the top of the content
export const addDisclaimer = (content: string): string => {
  return `/* This file was generated by Supernova, don't change manually */\n${content}`;
};

export const filterTokensByTypeAndGroup = (
  tokens: Token[],
  type: TokenType,
  group: string,
  excludeGroupNames?: string[] | null,
) => {
  const filteredTokens = filterExcludedTokens(tokens);

  return filteredTokens.filter((token) => {
    const hasMatchingType = token.tokenType === type;
    // Check if the group matches the first part of the token path (the actual group, not a subgroup)
    const tokenGroup = getTokenGroup(token);
    const isInGroup = tokenGroup === group.toLowerCase();

    // Also check if this token's group should be excluded
    const isExcluded = excludeGroupNames?.some((excludedGroup) => tokenGroup === excludedGroup.toLowerCase());

    return hasMatchingType && isInGroup && !isExcluded;
  });
};

export const filterTokensByType = (tokens: Token[], type: TokenType, excludeGroupNames?: string[] | null) => {
  const filteredTokens = filterExcludedTokens(tokens);

  return filteredTokens.filter((token) => {
    const hasMatchingType = token.tokenType === type;

    // Also check if this token's group should be excluded
    if (excludeGroupNames && excludeGroupNames.length > 0) {
      const tokenGroup = getTokenGroup(token);
      const isExcluded = excludeGroupNames.some((excludedGroup) => tokenGroup === excludedGroup.toLowerCase());

      return hasMatchingType && !isExcluded;
    }

    return hasMatchingType;
  });
};

const addEmptyLineBetweenTokenGroups = (index: number, length: number): string => {
  return index !== length - 1 ? '\n\n' : '\n';
};

type ProcessTokensResult = {
  styles: string;
  mixin: string;
  stylesObject: StylesObjectType;
};

const processTokensForType = (
  filteredTokens: Token[],
  tokenType: TokenType,
  mappedTokens: Map<string, Token>,
  tokenGroups: Array<TokenGroup>,
  tokenPrefix: string,
  hasMixin: boolean,
  hasParentPrefix: boolean,
  sortByNumValue: boolean,
  hasJsOutput: boolean,
  fontSizeBaseMap: FontSizeBaseMap,
  deviceDimensions?: DeviceDimensionMap,
): ProcessTokensResult => {
  let styles = '';
  let mixin = '';

  // Generate css tokens
  if (tokenType !== TokenType.typography) {
    const generatedStyles = generateStylesFromTokens(
      filteredTokens,
      mappedTokens,
      tokenGroups,
      tokenPrefix,
      hasMixin,
      hasParentPrefix,
      sortByNumValue,
      hasJsOutput,
      fontSizeBaseMap,
    );
    if (generatedStyles) {
      styles += generatedStyles;
      styles += '\n\n';
    }
  }

  // Generate mixin
  if (!hasJsOutput && hasMixin) {
    mixin += generateMixinFromTokens(filteredTokens, tokenGroups, tokenPrefix, hasParentPrefix, sortByNumValue);
  }

  // Generate css object
  const groupStylesObject = generateStylesObjectFromTokens(
    filteredTokens,
    tokenGroups,
    hasParentPrefix,
    hasJsOutput,
    sortByNumValue,
    deviceDimensions,
    fontSizeBaseMap,
    mappedTokens,
  );

  return {
    styles,
    mixin,
    stylesObject: groupStylesObject,
  };
};

type ExportTemplateCallback = (entriesLength: number) => (entry: [string, unknown], index: number) => string;

const jsExportTemplate: ExportTemplateCallback = (entriesLength) => {
  return ([key, obj], index) => {
    return `export const ${key} = {\n${convertToJs(obj as StylesObjectType)}\n};${addEmptyLineBetweenTokenGroups(index, entriesLength)}`;
  };
};

const scssExportTemplate: ExportTemplateCallback = (entriesLength) => {
  return ([key, obj], index) => {
    return `${key}: (\n${convertToScss(obj as StylesObjectType)}\n) !default;${addEmptyLineBetweenTokenGroups(index, entriesLength)}`;
  };
};

const generateObjectOutput = (stylesObject: StylesObjectType, callback: ExportTemplateCallback) => {
  const entries = Object.entries(stylesObject);

  return entries.map(callback(entries.length)).join('');
};

export const generateJsObjectOutput = (stylesObject: StylesObjectType): string => {
  return generateObjectOutput(stylesObject, jsExportTemplate);
};

export const generateScssObjectOutput = (stylesObject: StylesObjectType): string => {
  return generateObjectOutput(stylesObject, scssExportTemplate);
};

export const getGroups = (
  tokens: Token[],
  excludeGroupNames: string[] | null,
  groupNames: string[] | undefined,
): string[] => {
  let groups;
  const excludeGroupNamesNormalized = excludeGroupNames?.map((name) => name.toLowerCase()) ?? null;
  const groupNamesNormalized = groupNames?.map((name) => name.toLowerCase()) ?? [];

  if (excludeGroupNamesNormalized && excludeGroupNamesNormalized.length > 0) {
    const filteredTokens = tokens.filter((token) => {
      // Check if the excluded group matches the first part of the token path (the actual group, not a subgroup)
      const tokenGroup = getTokenGroup(token);

      return !excludeGroupNamesNormalized.some((excludedGroup) => tokenGroup === excludedGroup);
    });

    const restOfGroupNames = filteredTokens.reduce((acc: string[], token) => {
      const groupName = getTokenGroup(token);
      if (groupName && !acc.includes(groupName)) {
        acc.push(groupName);
      }

      return acc;
    }, []);

    groups = [...new Set(restOfGroupNames)];
  } else {
    groups = groupNamesNormalized;
  }

  return groups;
};

export interface GenerateFileContent {
  tokens: Token[];
  mappedTokens: Map<string, Token>;
  tokenGroups: Array<TokenGroup>;
  fileData: FileData;
  hasJsOutput: boolean;
  deviceDimensions?: DeviceDimensionMap;
  fontSizeBaseMapOverride?: FontSizeBaseMap;
}

export const generateFileContent = ({
  tokens,
  mappedTokens,
  tokenGroups,
  fileData,
  hasJsOutput,
  deviceDimensions,
  fontSizeBaseMapOverride,
}: GenerateFileContent) => {
  let styledTokens = '';
  let stylesObject: StylesObjectType = {};
  let styledMixin = '';
  const fontSizeBaseMap = fontSizeBaseMapOverride ?? getFontSizeBaseMap(tokens);
  const {
    excludeGroupNames = null,
    groupNames,
    hasMixin = false,
    hasParentPrefix = true,
    hasStylesObject = true,
    sortByNumValue = false,
    tokenTypes,
  } = fileData;

  // Check if group filtering should be applied
  // Apply group filtering if:
  // 1. groupNames is provided and not empty, OR
  // 2. excludeGroupNames is provided (which means we want to filter by groups, excluding some)
  const shouldFilterByGroup =
    (groupNames && groupNames.length > 0 && groupNames[0] !== '') ||
    (excludeGroupNames && excludeGroupNames.length > 0);

  // Calculate token prefix once since it doesn't depend on tokenType
  const tokenPrefix = findTokenPrefix(tokens);

  // Iterate over token types and groups to filter tokens
  tokenTypes.forEach((tokenType) => {
    if (shouldFilterByGroup) {
      // Filter by both type and group
      // When excludeGroupNames is provided but no groupNames, we need to filter by type first
      // to avoid including groups from other token types
      const tokensToConsider =
        groupNames && groupNames.length > 0 && groupNames[0] !== ''
          ? tokens
          : filterTokensByType(tokens, tokenType, excludeGroupNames);

      const groups = getGroups(tokensToConsider, excludeGroupNames, groupNames);

      groups.forEach((group) => {
        const filteredTokens = filterTokensByTypeAndGroup(tokens, tokenType, group, excludeGroupNames);

        const result = processTokensForType(
          filteredTokens,
          tokenType,
          mappedTokens,
          tokenGroups,
          tokenPrefix,
          hasMixin,
          hasParentPrefix,
          sortByNumValue,
          hasJsOutput,
          fontSizeBaseMap,
          deviceDimensions,
        );

        styledTokens += result.styles;
        styledMixin += result.mixin;
        stylesObject = deepMergeObjects(stylesObject, result.stylesObject);
      });
    } else {
      // Filter by type only (no group filtering)
      const filteredTokens = filterTokensByType(tokens, tokenType, excludeGroupNames);

      const result = processTokensForType(
        filteredTokens,
        tokenType,
        mappedTokens,
        tokenGroups,
        tokenPrefix,
        hasMixin,
        hasParentPrefix,
        sortByNumValue,
        hasJsOutput,
        fontSizeBaseMap,
        deviceDimensions,
      );

      styledTokens += result.styles;
      styledMixin += result.mixin;
      stylesObject = deepMergeObjects(stylesObject, result.stylesObject);
    }
  });

  // Remove trailing newlines from styledTokens
  const trimmedStyledTokens = styledTokens.trimEnd();
  let content = trimmedStyledTokens;

  // convert css object to scss or js structure based on file extension
  if (hasStylesObject) {
    const objectOutput = hasJsOutput ? generateJsObjectOutput(stylesObject) : generateScssObjectOutput(stylesObject);
    // Add newline separator only if there's existing content
    if (content) {
      content += '\n\n';
    }
    content += objectOutput;
  }

  if (!hasJsOutput && hasMixin) {
    // Add newline separator only if there's existing content
    if (content) {
      content += '\n\n';
    }
    content += styledMixin;
  }

  return {
    content: addDisclaimer(indentAndFormat(content, hasJsOutput)),
  };
};
